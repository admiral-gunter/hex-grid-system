<!DOCTYPE html>
<html>
<head>
  <title>Hex Grid Movement - Multiple Units (Traditional Functions)</title>
  <style>
    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <!-- 1080 x 1920 -->
  <div style="position: relative; width: 1920px; height: 1080px;">
    <canvas id="gameCanvas" width="1920" height="1080" style="z-index: 1; position: absolute; top: 0; left: 0;"></canvas>

    <!-- Shader overlay div (if needed) -->
    <div id="shaderOverlay" style="
      position: absolute;
      top: 0;
      left: 0;
      width: 1920px;
      height: 1080px;
      z-index: 2;
      pointer-events: none;
      background-size: cover;
    "></div>
  </div>

  <div id="status">Click a unit to select it, then click an adjacent hex to move it</div>
  <script>
    // Traditional function for Hex (axial coordinates)
    function Hex(q, r) {
      this.q = q;
      this.r = r;
    }
    Hex.prototype.getPixelX = function(hexSize) {
      return hexSize * (Math.sqrt(3) * this.q + Math.sqrt(3)/2 * this.r);
    };
    Hex.prototype.getPixelY = function(hexSize) {
      return hexSize * (3/2 * this.r);
    };

    // Traditional function for Grid
    function Grid(radius) {
      this.hexes = [];
      for (var q = -radius; q <= radius; q++) {
        for (var r = -radius; r <= radius; r++) {
          if (Math.abs(q + r) <= radius) {
            this.hexes.push(new Hex(q, r));
          }
        }
      }
    }

    // Global Variables and Canvas setup.
    var canvas = document.getElementById('gameCanvas');
    var ctx = canvas.getContext('2d');
    var HEX_SIZE = 90;
    var grid = new Grid(3);

    // Compute pixel center from axial coordinates.
    function getPixelFromAxial(pos) {
      var hex = new Hex(pos.q, pos.r);
      return {
        x: hex.getPixelX(HEX_SIZE) + canvas.width / 2,
        y: hex.getPixelY(HEX_SIZE) + canvas.height / 2
      };
    }

    // Load the tile image for hexes.
    var tileImage = new Image();
    tileImage.src = 'assets/imgs/hex.jpg';
    tileImage.onload = function() {
      draw(); // Redraw when the image is loaded.
    };

    // Draw an individual hex with a tile image.
    function drawHex(hex) {
      var x = hex.getPixelX(HEX_SIZE) + canvas.width / 2;
      var y = hex.getPixelY(HEX_SIZE) + canvas.height / 2;
      ctx.beginPath();
      for (var i = 0; i < 6; i++) {
        var angle = Math.PI / 3 * i + Math.PI / 6;
        var px = x + HEX_SIZE * Math.cos(angle);
        var py = y + HEX_SIZE * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.save();
      ctx.clip();
      ctx.drawImage(tileImage, x - HEX_SIZE, y - HEX_SIZE, HEX_SIZE * 2, HEX_SIZE * 2);
      ctx.restore();
      ctx.strokeStyle = '#333';
      ctx.stroke();
    }

    // Load images for units.
    var merkavaImage = new Image();
    merkavaImage.src = 'assets/imgs/merkava-mk1.png';
    var abramsImage = new Image();
    abramsImage.src = 'assets/imgs/abrams.png';

    // Traditional function for Unit
    function Unit(options) {
      // options should contain: id, type, pos (axial {q, r}), image, angle, drawOffset (optional)
      this.id = options.id;
      this.type = options.type;
      this.pos = options.pos; // axial coordinates
      this.image = options.image;
      this.angle = options.angle || 0;
      this.drawOffset = options.drawOffset || { width: HEX_SIZE + 50, height: HEX_SIZE - 20 };
      this.selected = false;
      // Initial pixel position based on axial position.
      this.pixelPos = getPixelFromAxial(this.pos);
      if(options.fxd_h != null && options.fxd_w != null ){
        this.fxd_h = options.fxd_h;
        this.fxd_w = options.fxd_w;
      }

    }
    Unit.prototype.updatePixelPos = function() {
      this.pixelPos = getPixelFromAxial(this.pos);
    };
    Unit.prototype.draw = function() {
      var x = this.pixelPos.x;
      var y = this.pixelPos.y;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(this.angle * Math.PI / 3); // adjust rotation if needed
      if(this.fxd_h){

        // Draw unit image centered.
        ctx.drawImage(this.image, -this.drawOffset.width / 2, -this.drawOffset.height / 2, this.drawOffset.width + this.fxd_w, this.drawOffset.height+ this.fxd_h);
      }else{
        ctx.drawImage(this.image, -this.drawOffset.width / 2, -this.drawOffset.height / 2, this.drawOffset.width, this.drawOffset.height);

      }
      // If the unit is selected, draw an outline.
      if (this.selected) {
        ctx.beginPath();
        ctx.arc(0, 0, HEX_SIZE/2 + 5, 0, 2 * Math.PI);
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 4;
        ctx.stroke();
      }
      ctx.restore();
    };
    Unit.prototype.isClicked = function(mouseX, mouseY) {
      var dx = mouseX - this.pixelPos.x;
      var dy = mouseY - this.pixelPos.y;
      return Math.sqrt(dx * dx + dy * dy) < HEX_SIZE / 2;
    };

    // Initialize the global object with US and ISRAEL faction arrays.
    var units = {
      "ISRAEL": [],
      "US": []
    };




    // Helper function to get a flat array of all units
    function getAllUnits() {
      var all = [];
      for (var faction in units) {
        if (units.hasOwnProperty(faction)) {
          all = all.concat(units[faction]);
        }
      }
      return all;
    }

    // Add a Merkava unit at axial (0, 0) to ISRAEL faction.
    units['ISRAEL'].push(new Unit({
      id: 1,
      type: 'MERKAVA',
      pos: { q: 0, r: 0 },
      image: merkavaImage,
      angle: -1,
      fxd_h:5,
      fxd_w:10,
    }));

    // Add an Abrams unit at axial (2, -1) to US faction.
    units['US'].push(new Unit({
      id: 2,
      type: 'M1ABRAMS',
      pos: { q: 2, r: -1 },
      image: abramsImage,
      angle: 2
    }));

    // Check if two hexes (given in axial coordinates) are adjacent.
    function areAdjacent(hex1, hex2) {
      var cube1 = { x: hex1.q, z: hex1.r, y: -hex1.q - hex1.r };
      var cube2 = { x: hex2.q, z: hex2.r, y: -hex2.q - hex2.r };
      var dx = Math.abs(cube1.x - cube2.x);
      var dy = Math.abs(cube1.y - cube2.y);
      var dz = Math.abs(cube1.z - cube2.z);
      return (dx + dy + dz) / 2 === 1;
    }

    // Animate the movement of a unit.
    function animateUnitMovement(unit, startPos, endPos, duration, targetHex) {
      var startTime = performance.now();
      function animate(currentTime) {
        var elapsed = currentTime - startTime;
        var t = elapsed / duration;
        if (t > 1) t = 1;
        // Linear interpolation of pixel positions.
        unit.pixelPos.x = startPos.x + (endPos.x - startPos.x) * t;
        unit.pixelPos.y = startPos.y + (endPos.y - startPos.y) * t;
        draw(); // Redraw the scene.
        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          // End of animation.
          unit.pixelPos = { x: endPos.x, y: endPos.y };
          // Update the unit's logical axial coordinates.
          unit.pos = { q: targetHex.q, r: targetHex.r };
          unit.selected = false; // Deselect after moving.
          draw();
        }
      }
      requestAnimationFrame(animate);
    }

    // The main draw function: draws the grid and every unit.
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      grid.hexes.forEach(function(hex) {
        drawHex(hex);
      });
      // Draw each unit from all factions.
      getAllUnits().forEach(function(unit) {
        unit.draw();
      });
    }

    // Click handler: first check if any unit was clicked.
    canvas.addEventListener('click', function(event) {
      var rect = canvas.getBoundingClientRect();
      var mouseX = event.clientX - rect.left;
      var mouseY = event.clientY - rect.top;
      
      // If any unit is clicked, select that one (deselecting others).
      var clickedUnit = null;
      var allUnits = getAllUnits();
      for (var i = 0; i < allUnits.length; i++) {
        if (allUnits[i].isClicked(mouseX, mouseY)) {
          clickedUnit = allUnits[i];
          break;
        }
      }
      if (clickedUnit) {
        // Deselect all units from all factions.
        allUnits.forEach(function(u) { u.selected = false; });
        clickedUnit.selected = true;
        draw();
        return; // Stop further processing for this click.
      }

      // If no unit was clicked, check if a unit is currently selected
      // and then see if the click is on a valid (adjacent) hex.
      var selectedUnit = allUnits.find(function(u) { return u.selected; });
      if (selectedUnit) {
        // Find the closest hex to the click.
        var closestHex = null;
        var minDist = Infinity;
        grid.hexes.forEach(function(hex) {
          var hexCenterX = hex.getPixelX(HEX_SIZE) + canvas.width / 2;
          var hexCenterY = hex.getPixelY(HEX_SIZE) + canvas.height / 2;
          var dx = mouseX - hexCenterX;
          var dy = mouseY - hexCenterY;
          var dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            closestHex = hex;
          }
        });

        // if (closestHex && minDist < HEX_SIZE) {
          // Only allow movement if the hex is adjacent.
          var currentHex = new Hex(selectedUnit.pos.q, selectedUnit.pos.r);
          // if (areAdjacent(currentHex, closestHex)) {
            var startPos = { x: selectedUnit.pixelPos.x, y: selectedUnit.pixelPos.y };
            var endPos = {
              x: closestHex.getPixelX(HEX_SIZE) + canvas.width / 2,
              y: closestHex.getPixelY(HEX_SIZE) + canvas.height / 2
            };
            animateUnitMovement(selectedUnit, startPos, endPos, 300, closestHex);
          // } else {
            console.log("Clicked hex is not adjacent to the selected unit.");
          // }
        // }
      }
    });

    // Initial draw.
    draw();
  </script>
</body>
</html>
